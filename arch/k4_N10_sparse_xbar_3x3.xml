<!-- 
Area-delay optimized for K06 N8 L4 W320 22nm pass-transistor based FPGA with 0.2V of gate-boosting
Fcin = 0.2, Fcout = 0.10 right, 0.10 bottom
All CLB delays and routing delays obtained from HSPICE as part of this work.
Soft logic blocks use 50% depopulated crossbars
Scaling assumptions from 40nm to 22nm: delay constant area drop (22/40)^2 but since VPR is in min W transistor areas, no area scaling is needed
-->
<architecture>
  
  <!-- ODIN II specific config -->
  <models>
  </models>
  <!-- ODIN II specific config ends -->
  <!-- Physical descriptions begin -->
  <layout>
    <!--- <auto_layout aspect_ratio="1.0"> -->
   <fixed_layout name="fixedly" width="5" height="5">
	   <!-- <auto_layout> -->
        <!--Perimeter of 'io' blocks with 'EMPTY' blocks at corners-->
        <perimeter type="io" priority="100"/>
        <corners type="EMPTY" priority="101"/>
        <!--Fill with 'clb'-->
        <fill type="clb" priority="10"/>
        <!--Column of 'mult_36' with 'EMPTY' blocks wherever a 'mult_36' does not fit. Vertical offset by 1 for perimeter.
        <col type="mult_36" startx="6" starty="1" repeatx="8" priority="20"/>
        <col type="EMPTY" startx="6" repeatx="8" starty="1" priority="19"/>-->
        <!--Column of 'memory' with 'EMPTY' blocks wherever a 'memory' does not fit. Vertical offset by 1 for perimeter.
        <col type="memory" startx="2" starty="1" repeatx="8" priority="20"/>
        <col type="EMPTY" startx="2" repeatx="8" starty="1" priority="19"/>-->
	<!-- </auto_layout> -->
	</fixed_layout>
</layout>
		<device>
			<sizing R_minW_nmos="13090.000000" R_minW_pmos="19086.831111"/>
			<area grid_logic_tile_area="13472"/> <!-- non frac is 12055 -->
			<chan_width_distr>
				<x distr="uniform" peak="1.000000"/>
				<y distr="uniform" peak="1.000000"/>
			</chan_width_distr>
			<switch_block type="wilton" fs="3"/>
		<connection_block input_switch_name="ipin_cblock"/>
        </device>
		<switchlist>
			<switch type="mux" name="0" R="0.000000" Cin="0.000000e+00" Cout="0.000000e+00" Tdel="1.253e-10" mux_trans_size="1.50823" buf_size="23.9839"/>
		<!--switch ipin_cblock resistance set to yeild for 4x minimum drive strength buffer-->
        <switch type="mux" name="ipin_cblock" R="3272.5" Cout="0." Cin="0.000000e+00" Tdel="8.973e-11" mux_trans_size="1.256" buf_size="auto"/>
        </switchlist>
		<segmentlist>
			<segment freq="1.000000" length="4" type="unidir" Rmetal="0.000000" Cmetal="0.000000e+00">
			<mux name="0"/>
			<sb type="pattern">1 1 1 1 1</sb>
			<cb type="pattern">1 1 1 1</cb>
			</segment>
		</segmentlist>
	  <complexblocklist>
       <!-- Capacity is a unique property of I/Os, it is the maximum number of I/Os that can be placed at the same (X,Y) location on the FPGA -->
      <pb_type name="io" capacity="8">
        <input name="outpad" num_pins="1"/>
        <output name="inpad" num_pins="1"/>
        <clock name="clock" num_pins="1"/>
        <!-- IOs can operate as either inputs or outputs -->
        <mode name="inpad">
          <pb_type name="inpad" blif_model=".input" num_pb="1">
            <output name="inpad" num_pins="1"/>
          </pb_type>
          <interconnect>
            <direct name="inpad" input="inpad.inpad" output="io.inpad">
            <delay_constant max="4.243e-11" in_port="inpad.inpad" out_port="io.inpad"/>
            </direct>
          </interconnect>
      
        </mode>
        <mode name="outpad">
          <pb_type name="outpad" blif_model=".output" num_pb="1">
            <input name="outpad" num_pins="1"/>
          </pb_type>
          <interconnect>
            <direct name="outpad" input="io.outpad" output="outpad.outpad">
            <delay_constant max="1.394e-11" in_port="io.outpad" out_port="outpad.outpad"/>
            </direct>
          </interconnect>
        </mode>
        <fc in_type="frac" in_val="0.2" out_type="frac" out_val="0.10"/>
        <!-- IOs go on the periphery of the FPGA, for consistency, 
          make it physically equivalent on all sides so that only one definition of I/Os is needed.
          If I do not make a physically equivalent definition, then I need to define 4 different I/Os, one for each side of the FPGA
        -->
        <pinlocations pattern="custom">
          <loc side="left">io.outpad io.inpad io.clock</loc>
          <loc side="top">io.outpad io.inpad io.clock</loc>
          <loc side="right">io.outpad io.inpad io.clock</loc>
          <loc side="bottom">io.outpad io.inpad io.clock</loc>
        </pinlocations>
        </pb_type>
      <!-- Logic cluster definition -->
      <pb_type name="clb">
        <input name="I1" num_pins="6" equivalent="full"/>
        <input name="I2" num_pins="6" equivalent="full"/>
        <input name="I3" num_pins="6" equivalent="full"/>
        <input name="I4" num_pins="6" equivalent="full"/>
        <output name="O" num_pins="10" equivalent="none"/>
        <clock name="clk" num_pins="1"/>
    <!-- Basic logic element definition -->
		<pb_type name="ble4" num_pb="10">
		  <input name="in_A" num_pins="1"/>
		  <input name="in_B" num_pins="1"/>
		  <input name="in_C" num_pins="1"/>
		  <input name="in_D" num_pins="1"/>
		  <output name="out_local" num_pins="1"/>
		  <output name="out_routing" num_pins="1"/>
		  <clock name="clk" num_pins="1"/> 
		  
		  <mode name="4ble">
			  
			  <pb_type name="lut4" blif_model=".names" num_pb="1" class="lut">
				<input name="in" num_pins="4" port_class="lut_in"/>
				<!-- I average out the delays because VPR does not to LUT balancing -->
				<output name="out" num_pins="1" port_class="lut_out"/>
					  <delay_matrix type="max" in_port="lut4.in" out_port="lut4.out">
					   1.45353e-10
					   1.45353e-10
					   1.45353e-10
					   1.45353e-10
				</delay_matrix>      
			  </pb_type>
			  
			  <pb_type name="ff" blif_model=".latch" num_pb="1" class="flipflop">
				<input name="D" num_pins="1" port_class="D"/>
				<output name="Q" num_pins="1" port_class="Q"/>
				<clock name="clk" num_pins="1" port_class="clock"/>
				<T_setup value="1.891e-11" port="ff.D" clock="clk"/>
				<T_clock_to_Q max="6.032e-11" port="ff.Q" clock="clk"/>
			  </pb_type>
			  
			  <interconnect>
				<!-- BLE input to LUT input direct connections and delays -->
				<direct name="direct1" input="ble4.in_A" output="lut4.in[0:0]"/>
				<direct name="direct2" input="ble4.in_B" output="lut4.in[1:1]"/>
				<direct name="direct7" input="ble4.in_C" output="lut4.in[2:2]"/>
				<direct name="direct3" input="ble4.in_D" output="lut4.in[3:3]"/>
				<direct name="direct8" input="lut4.out" output="ff.D">
					<pack_pattern name="ble4" in_port="lut4.out" out_port="ff.D"/>
				</direct>
				<direct name="direct6" input="ble4.clk" output="ff.clk"/>			
				
				<!-- BLE output (local) -->                  
				<mux name="mux_local" input="ff.Q lut4.out" output="ble4.out_local[0:0]">
					<delay_constant max="1.053e-10" in_port="ff.Q" out_port="ble4.out_local[0:0]"/>
					<delay_constant max="1.053e-10" in_port="lut4.out" out_port="ble4.out_local[0:0]"/>
				</mux>
				
				<!-- BLE output (routing 1) --> 
				<mux name="mux_routing" input="ff.Q lut4.out" output="ble4.out_routing[0:0]">
				  <delay_constant max="3.912e-11" in_port="ff.Q" out_port="ble4.out_routing[0:0]"/>
				  <delay_constant max="3.912e-11" in_port="lut4.out" out_port="ble4.out_routing[0:0]"/>
				</mux>
			</interconnect>

		  </mode>

		</pb_type>
        
         <interconnect>
          <!-- 50% sparsely populated local routing -->
          <complete name="lutA" input="clb.I4 clb.I3 ble4[2:0].out_local" output="ble4[9:0].in_A">
            <delay_constant max="6.604e-11" in_port="clb.I1" out_port="ble4.in_A"/>
          </complete>
          <complete name="lutB" input="clb.I3 clb.I2 ble4[4:2].out_local" output="ble4[9:0].in_B">
            <delay_constant max="6.604e-11" in_port="clb.I1" out_port="ble4.in_B"/>
            </complete>
          <complete name="lutC" input="clb.I2 clb.I1 ble4[6:4].out_local" output="ble4[9:0].in_C">
            <delay_constant max="6.604e-11" in_port="clb.I1" out_port="ble4.in_C"/>
            </complete>
          <complete name="lutD" input="clb.I1 clb.I4 ble4[9:7].out_local" output="ble4[9:0].in_D">
            <delay_constant max="6.604e-11" in_port="clb.I1" out_port="ble4.in_D"/>
            </complete>
          <complete name="clks" input="clb.clk" output="ble4[9:0].clk">
          </complete>
          
          <!-- Direct connections to CLB outputs -->
          <direct name="clbouts1" input="ble4[9:0].out_routing" output="clb.O"/>
        </interconnect>
        <fc in_type="frac" in_val="0.2" out_type="frac" out_val="0.10"/>
        <!-- Two sided connectivity CLB architecture--> 
        <pinlocations pattern="custom">
          <loc side="right">clb.O clb.I1 clb.I2 clb.clk</loc> 
          <loc side="top">clb.O clb.I3 clb.I4</loc>     
        </pinlocations>
        </pb_type>
    </complexblocklist>
  </architecture>
